// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

let Js_dict = require("@rescript/runtime/lib/js/Js_dict.js");
let Stdlib_List = require("@rescript/runtime/lib/js/Stdlib_List.js");
let Primitive_option = require("@rescript/runtime/lib/js/Primitive_option.js");
let Primitive_exceptions = require("@rescript/runtime/lib/js/Primitive_exceptions.js");

let DecodeError = /* @__PURE__ */Primitive_exceptions.create("Json_Decode-JsonCombinators.DecodeError");

function expected(kind, json) {
  throw {
    RE_EXN_ID: DecodeError,
    _1: `Expected ` + kind + `, got ` + JSON.stringify(json),
    Error: new Error()
  };
}

let $$Error = {
  expected: expected
};

function custom(f) {
  return f;
}

function id(json) {
  return json;
}

function float(json) {
  if (typeof json !== "number") {
    expected("float", json);
  }
  return json;
}

function int(json) {
  if (typeof json !== "number") {
    expected("int", json);
  }
  let truncated = (json | 0);
  if (truncated !== json || !Number.isFinite(json)) {
    expected("int", json);
  }
  return json;
}

function bool(json) {
  if (typeof json !== "boolean") {
    expected("bool", json);
  }
  return json;
}

function string(json) {
  if (typeof json !== "string") {
    expected("string", json);
  }
  return json;
}

function array(decode) {
  return json => {
    if (!Array.isArray(json)) {
      expected("array", json);
    }
    let target = (new Array(json.length));
    for (let i = 0, i_finish = json.length; i < i_finish; ++i) {
      try {
        let value = decode((json[i]));
        target[i] = value;
      } catch (raw_msg) {
        let msg = Primitive_exceptions.internalToException(raw_msg);
        if (msg.RE_EXN_ID === DecodeError) {
          throw {
            RE_EXN_ID: DecodeError,
            _1: msg._1 + `\n\tin array at index ` + i.toString(),
            Error: new Error()
          };
        }
        throw msg;
      }
    }
    return target;
  };
}

function list(decode) {
  return json => Stdlib_List.fromArray(array(decode)(json));
}

function option(decode) {
  return json => {
    if (json === null) {
      return;
    } else {
      return Primitive_option.some(decode(json));
    }
  };
}

function date(json) {
  return new Date(string(json));
}

function tuple2(decodeA, decodeB) {
  return json => {
    if (!Array.isArray(json)) {
      expected("array", json);
    }
    if (json.length !== 2) {
      throw {
        RE_EXN_ID: DecodeError,
        _1: `Expected array of length 2, got array of length ` + json.length.toString(),
        Error: new Error()
      };
    }
    try {
      return [
        decodeA(json[0]),
        decodeB(json[1])
      ];
    } catch (raw_msg) {
      let msg = Primitive_exceptions.internalToException(raw_msg);
      if (msg.RE_EXN_ID === DecodeError) {
        throw {
          RE_EXN_ID: DecodeError,
          _1: msg._1 + `\n\tin pair`,
          Error: new Error()
        };
      }
      throw msg;
    }
  };
}

function tuple3(decodeA, decodeB, decodeC) {
  return json => {
    if (!Array.isArray(json)) {
      expected("array", json);
    }
    if (json.length !== 3) {
      throw {
        RE_EXN_ID: DecodeError,
        _1: `Expected array of length 3, got array of length ` + json.length.toString(),
        Error: new Error()
      };
    }
    try {
      return [
        decodeA(json[0]),
        decodeB(json[1]),
        decodeC(json[2])
      ];
    } catch (raw_msg) {
      let msg = Primitive_exceptions.internalToException(raw_msg);
      if (msg.RE_EXN_ID === DecodeError) {
        throw {
          RE_EXN_ID: DecodeError,
          _1: msg._1 + `\n\tin pair`,
          Error: new Error()
        };
      }
      throw msg;
    }
  };
}

function tuple4(decodeA, decodeB, decodeC, decodeD) {
  return json => {
    if (!Array.isArray(json)) {
      expected("array", json);
    }
    if (json.length !== 4) {
      throw {
        RE_EXN_ID: DecodeError,
        _1: `Expected array of length 4, got array of length ` + json.length.toString(),
        Error: new Error()
      };
    }
    try {
      return [
        decodeA(json[0]),
        decodeB(json[1]),
        decodeC(json[2]),
        decodeD(json[3])
      ];
    } catch (raw_msg) {
      let msg = Primitive_exceptions.internalToException(raw_msg);
      if (msg.RE_EXN_ID === DecodeError) {
        throw {
          RE_EXN_ID: DecodeError,
          _1: msg._1 + `\n\tin pair`,
          Error: new Error()
        };
      }
      throw msg;
    }
  };
}

function dict(decode) {
  return json => {
    if (typeof json !== "object" || Array.isArray(json) || json === null) {
      expected("object", json);
    }
    try {
      return Js_dict.map(decode, json);
    } catch (raw_msg) {
      let msg = Primitive_exceptions.internalToException(raw_msg);
      if (msg.RE_EXN_ID === DecodeError) {
        throw {
          RE_EXN_ID: DecodeError,
          _1: msg._1 + `\n\tin dict'`,
          Error: new Error()
        };
      }
      throw msg;
    }
  };
}

function keyArray(decode) {
  return json => Js_dict.entries(dict(decode)(json));
}

function keyList(decode) {
  return json => Stdlib_List.fromArray(Js_dict.entries(dict(decode)(json)));
}

function keyArrayValues(decode) {
  return json => Js_dict.values(dict(decode)(json));
}

function keyListValues(decode) {
  return json => Stdlib_List.fromArray(Js_dict.values(dict(decode)(json)));
}

function field(key, decode) {
  return json => {
    if (typeof json !== "object" || Array.isArray(json) || json === null) {
      expected("object", json);
    }
    if (!(key in json)) {
      throw {
        RE_EXN_ID: DecodeError,
        _1: key + ` required`,
        Error: new Error()
      };
    }
    try {
      return decode((json[key]));
    } catch (raw_msg) {
      let msg = Primitive_exceptions.internalToException(raw_msg);
      if (msg.RE_EXN_ID === DecodeError) {
        throw {
          RE_EXN_ID: DecodeError,
          _1: msg._1 + `\n\tat field '` + key + `'`,
          Error: new Error()
        };
      }
      throw msg;
    }
  };
}

function oneOf(decoders) {
  return json => {
    let errors = [];
    let _i = 0;
    while (true) {
      let i = _i;
      if (i >= decoders.length) {
        throw {
          RE_EXN_ID: DecodeError,
          _1: `All decoders given to oneOf failed. Here are all the errors:\n- ` + errors.join("\n") + `\nAnd the JSON being decoded: ` + JSON.stringify(json),
          Error: new Error()
        };
      }
      let decode = decoders[i];
      try {
        return decode(json);
      } catch (raw_err) {
        let err = Primitive_exceptions.internalToException(raw_err);
        if (err.RE_EXN_ID === DecodeError) {
          errors.push(err._1);
          _i = i + 1 | 0;
          continue;
        }
        throw err;
      }
    };
  };
}

function object(f) {
  return json => {
    if (typeof json !== "object" || Array.isArray(json) || json === null) {
      throw expected("object", json);
    }
    let optional = (key, decode) => {
      if (!(key in json) || (json[key]) === null) {
        return;
      }
      try {
        return Primitive_option.some(decode((json[key])));
      } catch (raw_msg) {
        let msg = Primitive_exceptions.internalToException(raw_msg);
        if (msg.RE_EXN_ID === DecodeError) {
          throw {
            RE_EXN_ID: DecodeError,
            _1: msg._1 + `\n\tat field '` + key + `'`,
            Error: new Error()
          };
        }
        throw msg;
      }
    };
    let oneOf = a => {
      let errors = [];
      let _i = 0;
      while (true) {
        let i = _i;
        if (i >= a.length) {
          throw {
            RE_EXN_ID: DecodeError,
            _1: `All decoders given to oneOf failed. Here are all the errors:\n- ` + errors.join("\n") + `\nAnd the JSON being decoded: ` + JSON.stringify(json),
            Error: new Error()
          };
        }
        let match = a[i];
        try {
          return match[1]((json[match[0]]));
        } catch (raw_err) {
          let err = Primitive_exceptions.internalToException(raw_err);
          if (err.RE_EXN_ID === DecodeError) {
            errors.push(err._1);
            _i = i + 1 | 0;
            continue;
          }
          throw err;
        }
      };
    };
    let required = (key, decode) => {
      if (!(key in json)) {
        throw {
          RE_EXN_ID: DecodeError,
          _1: key + ` required`,
          Error: new Error()
        };
      }
      try {
        return decode((json[key]));
      } catch (raw_msg) {
        let msg = Primitive_exceptions.internalToException(raw_msg);
        if (msg.RE_EXN_ID === DecodeError) {
          throw {
            RE_EXN_ID: DecodeError,
            _1: msg._1 + `\n\tat field '` + key + `'`,
            Error: new Error()
          };
        }
        throw msg;
      }
    };
    let withDefault = (val, param, decode) => {
      try {
        return decode((json[key]));
      } catch (raw_exn) {
        Primitive_exceptions.internalToException(raw_exn);
        return val;
      }
    };
    return f({
      optional: optional,
      required: required,
      withDefault: withDefault,
      oneOf: oneOf
    });
  };
}

function map(decode, f) {
  return json => f(decode(json));
}

function flatMap(decodeA, f) {
  return json => {
    let decodeB = f(decodeA(json));
    return decodeB(json);
  };
}

function indirect(f) {
  return json => f()(json);
}

function decode(json, decode$1) {
  try {
    return {
      TAG: "Ok",
      _0: decode$1(json)
    };
  } catch (raw_msg) {
    let msg = Primitive_exceptions.internalToException(raw_msg);
    if (msg.RE_EXN_ID === DecodeError) {
      return {
        TAG: "Error",
        _0: msg._1
      };
    }
    throw msg;
  }
}

let pair = tuple2;

exports.DecodeError = DecodeError;
exports.$$Error = $$Error;
exports.custom = custom;
exports.id = id;
exports.float = float;
exports.int = int;
exports.bool = bool;
exports.string = string;
exports.array = array;
exports.list = list;
exports.object = object;
exports.option = option;
exports.date = date;
exports.pair = pair;
exports.tuple2 = tuple2;
exports.tuple3 = tuple3;
exports.tuple4 = tuple4;
exports.dict = dict;
exports.keyArray = keyArray;
exports.keyList = keyList;
exports.keyArrayValues = keyArrayValues;
exports.keyListValues = keyListValues;
exports.field = field;
exports.oneOf = oneOf;
exports.map = map;
exports.flatMap = flatMap;
exports.indirect = indirect;
exports.decode = decode;
/* No side effect */
